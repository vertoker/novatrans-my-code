## Модуль `VRF/`, папка `DataSources/`

Отдельная система для правильной инициализации конфигов всех проектов. Работает достаточно независимо,
полностью самостоятельное решение, которым я и сам отдельно пользуюсь

## Data Source

Система инициализации данных для начала игры

В основе стоят следующие понятия
- Модель - сборище данных для инициализации определённой части игры. Сама система чувствительна к их типам, поэтому
для разных систем нужны разные модели, даже если их данные совпадают
  - Эта модель должна быть `class`, быть `[Serializable]`, иметь `new()` и 
не наследоваться чего-либо кроме интерфейсов
- Источники (Data Sources) - системы сохранения/загрузки моделей, все они реализуют хотя-бы один из интерфейсов: 
`IDataSaver` или `IDataLoader`, и всегда реализуют `IDataSource`
  - По спецификации `IDataLoader`, он возвращает `null` если ничего не нашёл и саму модель, если нашёл
    - `force` означает, что если модель не найдена, то он вернёт вместо `null` новую пустую модель от `new()`
  - Все источники также имеют дополнительный класс с настройками, которые нужны при создании
    - В `VRF` все источники создаются в `ProjectContext` и там же их можно настроить

### `ContainerDataSource`

Первый и основной источник, который реализует интерфейсы `IDataSaver` и `IDataLoader` через другие источники. 
То есть в него добавляются остальные источники, которые он по очереди вызывает, пока не найдёт данные

Признаком того, что дочерний источник не нашёл данные - то, что тот вернёт `null`, в таком случае
перебор продолжиться пока он не пройдёт по всем загруженным источникам, или пока не найдёт любое не `null` значение

Для всех настоящих источников моделей, был создан `enum` - `DataSourceType`, который активно используется для 
назначения порядка загрузки моделей в самом `Unity Editor`

### `LocalCacheDataSource`

Самый простой источник, который реализует интерфейсы `IDataSaver` и `IDataLoader` и хранит данные внутри 
текущей сессии `Unity`, то есть внутри себя. Но его главная особенность в том, что он сам находится 
в `ProjectContext`, что позволяет хранить данные в самом контейнере и передавать данные между сценами.
Обычно именно для этого он и используется - передавать данные между сценами

Доступ к моделям реализуется по их типу, что означает необходимость соблюдения правила с разными типами 
для моделей

Также сам факт существования модели в источнике является переменной `bool`, что создало новый
вид моделей - флаги (`ModelFlag`), сам факт которых существования в источнике является сигналом для чего-то ещё

### `ScriptableDataSource`

Утилитарный источник, который реализует только `IDataLoader` и загружает данные только из `Scriptable` объектов.
Но как загрузить модель, если она не `ScriptableObject`? Для этого создан специальный механизм, который позволяет
хранить модели в новых типах **конфигов**. Они наследуются от `ScriptableObject` и всегда связаны только со 
своей моделью данных (которую они хранят)

Для более простых данных, можно просто создать класс от `BaseScriptableModel<TModel>`, а если нужна более сложная
логика (например данные модели, `Unity` не может просто так сериализовать), то нужно самостоятельно 
унаследоваться от `ScriptableObject` и `IScriptableModel` и написать свою логику загрузки модели

Обычно конфиги называют примерно так: `NetModel` - `NetConfig`, `AuthIdentityModel` - `AuthIdentityConfig`

(сам факт наличия конфига в источнике - означает, что модель этого типа к конфиге есть)

### `CommandLineDataSource`

Самый сложный источник данных, который реализует только `IDataLoader` и загружает данные из командной строки.
Так как аргументы командной строки нельзя преобразовать в модель, для этого сам источник оперирует **парсерами** - 
специальные классы, которые наследуются от `IModelCmdParser` и работают очень похоже на **конфиги**

**ВАЖНО**: - сам факт наличие парсера в источнике, означает, что вы **гарантируете**, что он сработает и загрузит
модель из данных командной строки

**ВАЖНО**: - разные парсеры для одной модели **не сочетаются**, поэтому если хотите перезаписать стандартные `VRF`
парсеры аргументов, то **отключите бинд стандартных парсеров** и сделайте бинд своих до инсталлеров

Работа по парсингу происходит через вспомогательный класс `CommandLineParser`, который уже имеет аргументы
из командной строки и имеет множество утилит для парсинга данных, в основном для стиля `Unix` (где сначала 
указывается флаг `-p --port`, а после него данные `7777`)

Также для тестинга данных в редакторе, можно указать в настройках источника `CommandLineArgsConfig`, который 
будет имитировать аргументы командной строки если запуск происходит в `Unity Editor`

### `ConfigParserDataSource`

Универсальный источник, который реализует интерфейсы `IDataSaver` и `IDataLoader` и сохраняет данные в файлы 
через `NewtonsoftJson`. Какую папку использовать и как называть файлы, можно указать в настройках источника

На данный момент из папок только те, которые работают в `Unity`, как для `editor`, так и для `runtime`

### `Custom`

Также можно самостоятельно добавить свой источник, для этого в `DataSourceType` есть ячейка `Custom`, которую можно
указывать для своих данных. Оно должно принципиально отличаться от стандартных источников, иначе прощё перезаписать 
текущие источники

## Как правильно использовать модели

Нужно через любой источник вызвать `Load<TModel>()` или `Save<TModel>(model)`
- Лучше всего использовать `ContainerDataSource` и при любых действиях использовать массив из `DataSourceType`, 
в котором указан порядок загрузки/сохранения данных. Все стандартные модели `VRF` его используют, если хотите 
создать - сначала посмотрите на исходный код этих реализаций
- Но если вы хотите только один конкретный источник данных и знаете, что другие вам не понадобятся, то используете 
уже конкретный источник, например `LocalCacheDataSource` когда нужно обмениваться данными внутри игровой сессии
между сценами

## Как правильно настроить/добавить свои реализации

В контексте реализации `VRF`, вся логика строиться на 3 этапах
1. В `ProjectContext` создаются ВСЕ источники и добавляются в `ContainerDataSource` и контейнер `Zenject`
2. В инсталлерах стандартных `VRF` моделей происходит инициализация в источники (добавляются парсеры или конфиги)
и также там создаются исполнительные классы, которые и реализуют логику исполнения
3. В исполнительных классах происходит загрузка стандартных моделей и начинается игра

Свои реализации обычно встраивают между этапами 1 и 2, используя кастомные инсталлеры. В них также происходит
своя инициализация в источники (добавляются кастомные парсеры и конфиги), после чего уже стандартные инсталлеры
продолжают свою работу

У стандартных инсталлеров всегда есть переменные, которые позволяют отключить стандартные вещи (стандартные
парсеры и конфиги)
